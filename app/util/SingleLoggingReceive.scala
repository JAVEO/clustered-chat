package util

import akka.event.LoggingReceive
import akka.actor.Actor.Receive
import akka.event.Logging
import akka.event.Logging.LogLevel
import akka.actor.ActorContext

/*
 * LoggingReceive extension that flattens itself when
 * invoking "orElse" method on it.
 * Let's say we have two LoggingReceives r1 and r2.
 * If we invoke 
 * 
 * r3 = r1 orElse r2
 * context become r3
 *
 * and then pass a message TestMsg to the actor, so that r1 doesn't
 * handle it, but r2 does, then we will see two log messages:
 *
 * ... received unhandled message TestMsg
 * ... received handled message TestMsg
 *
 * First of them was generated by r1, second one - by r2.
 * We don't need the first line in logs, because actor did handle the message.
 */

object SingleLoggingReceive {

  def apply(r: Receive)(implicit context: ActorContext): Receive = withLabel(null)(r)

  def withLabel(label: String, logLevel: LogLevel)(r: Receive)(implicit context: ActorContext): Receive = r match {
    case _: SingleLoggingReceive ⇒ r
    case _                 ⇒ if (context.system.settings.AddLoggingReceive) new SingleLoggingReceive(None, r, Option(label), logLevel) else r
  }

  def withLabel(label: String)(r: Receive)(implicit context: ActorContext): Receive = withLabel(label, Logging.DebugLevel)(r)
}

class SingleLoggingReceive(source: Option[AnyRef], val r: Receive, label: Option[String], logLevel: LogLevel)(implicit context: ActorContext) extends LoggingReceive(source, r, label)(context) {
  override def orElse[C <: Any, B >: Unit](that: PartialFunction[C, B]) = that match {
    case slr: SingleLoggingReceive =>
      orElse(slr.r)
    case pf: PartialFunction[Any, Unit] =>
      val r2: PartialFunction[Any, Unit] = r orElse pf
      new SingleLoggingReceive(source, r2, label, logLevel)
  }
}
