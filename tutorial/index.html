<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Reactive chat application with Play, Akka Cluster and Websockets</title>
</head>
<body>

<div>
    <h2>Reactive chat application with Play, Akka Cluster and Websockets</h2>

    <p>
        The purpose of this activator template is to illustrate how a horizontally scalable, reactive architecture with
        websockets can be implemented with use of <a href="http://tools.ietf.org/html/rfc6455">WebSockets</a> and <a
            href="http://akka.io/">Akka</a> with <a
            href="http://doc.akka.io/docs/akka/2.4.0/common/cluster.html">Akka Cluster</a>.
    </p>
</div>

<div>
    <h2>Challenge</h2>

    <p>
        <a href="http://tools.ietf.org/html/rfc6455">WebSockets</a> are a protocol which enables bi-directional
        communication between user's browser and the server.
        With use of websockets you can send messages to the server and receive them independently from HTTP
        request/response cycle. Websockets are a powerful protocol and are reshaping the web by enabling truly
        responsive and real-time user experience, eliminating the need for extra browser plugins (eg. Applet,
        Flash) or workarounds (remember Comet?).

        Common use cases of such communication mechanism include:
    <ul>
        <li>Chats, instant messangers</li>
        <li>Bidding platforms</li>
        <li>Multi-player games</li>
        <li>Various forms of on-line data broadcasting</li>
    </ul>

    While the answer is quite straight forward how to implement async communications with HTML5 on the browser side, you
    have many options on the backend.
    This tutorial decribes one good option how such scalable backend can be implemented.

    By going through this tutorial you will learn how to:
    <ul>
        <li>Create asynchronous message channels in your web pages with use of websockets.</li>
        <li>Tie websocket connections to a reactive, scalable backend.</li>
        <li>Implement the backend in a distributed, message driven manner where messages are shared between all cluster
            nodes.
        </li>
    </ul>
    Read on.
    </p>
</div>
<div>
    <h2>Solution</h2>

    You might wonder about best patterns and blend of technologies to implement such communication.
    This application template aims to be a blueprint of such implementation based on the core elements of the <a
        href="http://www.typesafe.com/products/typesafe-reactive-platform">Typesafe Reactive Platform</a>:
    <ul>
        <li>Play Framework</li>
        <li>Akka</li>
        <li>Scala</li>
    </ul>

    For persistence this application uses MongoDB with Play-ReactiveMongo.

    <p>
        Also an interesting challenge emerges when you decide to scale out your backend by adding server instances
        and require to maintain message distribution between these nodes ensuring their delivery to all clients,
        regardless of their connection to one particular cluster node.

        It turns out that such scenario can be handled by <a
            href="http://doc.akka.io/docs/akka/2.4.0/common/cluster.html">Akka Cluster</a> by enabling the distribution
        of messages among server instances within the cluster.
    </p>

    <p>
        Let's build an example application that demonstrates such use case.
        We chose to exhibit this architecture by implementing a chat web app scenario.
    </p>
</div>

<div>
    <h2>Frontend</h2>

    <img src="tutorial/application.png">

    <p>
        The web part of the application includes two web pages. The first one is home/index page.
        After opening a home/index page you will see a simple form to define your nickname.
        To go further to chat page, you should fill out the form and submit it.
        To go back to home page, you should press the `leave chat` link to exit the chat page.
        On the chat page users communicate by the following scenario: users create topics, subscribe
        to them and, if they happen to be subscribed to the same topic, they can chat.
        All chat messages are transferred through an active web socket.
    </p>

    <p>
        The whole client side chat logic is implemented within <a href="#code/app/assets/javascripts/chat.coffee"
                                                                  class="shortcut">chat.coffee</a> file, to keep our
        code compact.
        Moreover, we use <code>sbt-coffeescript</code> plugin (take a look at : <a href="#code/project/plugins.sbt"
                                                                                   class="shortcut">plugins.sbt</a>)
        to compile CoffeeScript sources to JavaScript.
        Examine the <code>chat.coffe</code> file to learn how:
    <ul>
        <li><code>WebSocket</code> object is instantiated</li>
        <li>messages are marshaled and unmarshaled with use of <code>JSON</code> object</li>
        <li>messages are sent upon form submit</li>
        <li>messages are received from the server by <code>onmessage</code> callback of the <code>WebSocket</code>
            object
        </li>
    </ul>
    </p>
</div>

<div>
    <h2>Backend</h2>

    <p>
        You would rather run cluster nodes not only in separate JVMs but also on different physical machines in
        production.
        This can be excessive for testing and experimenting. To simplify cluster setup, we will simulate it by starting
        three actor systems on different ports. The configuration of actor systems is located in <a
            href="#code/conf/application.conf" class="shortcut">application.conf</a> file.
    </p>

    <p>
        Nevertheless, you can adjust the configuration if your preference is to run them on different machines.
        This can be done by redefinition of the <code>akka.cluster.seed-nodes</code> section in the aforementioned
        <a href="#code/conf/application.conf" class="shortcut">application.conf</a> coniguration file.
    </p>

    <p>
        To demonstrate the communication between nodes we will start three Play app instances, as reflected in the
        <a href="#code/conf/application.conf" class="shortcut">application.conf</a> file.
        Assuming that this file remains unchanged, we will start the first Play application node on port 9001 of your
        box.
        Port 2551 will be used for remote communication. The second one will be started on port 9002 with port 2552 for
        remoting, and the last node on port 9003 and port
        2553 respectively.

        To achieve this aim you should run the following commands when using a Linux/Unix-like system:
    <ul>
        <li><code>./activator "run -Dhttp.port=9001 -Dakka.remote.netty.tcp.port=2551"</code></li>
        <li><code>./activator "run -Dhttp.port=9002 -Dakka.remote.netty.tcp.port=2552"</code></li>
        <li><code>./activator "run -Dhttp.port=9003 -Dakka.remote.netty.tcp.port=2553"</code></li>
    </ul>
    </p>

    <p>
        Also some sort of load balancer in front of the cluster (eg. <a href="http://www.haproxy.org/">HAProxy</a>)
        is required to distribute the traffic between nodes in a real world scenario.
        <br/>
        Load balancer configuration is beyond the scope of this tutorial, but let us just note that care should be taken
        to
        configure the load balancer properly, to maintain active websocket connections in a multinode setup.
        More info on HAProxy configuration for websockets can be found
        <a href="http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/">here</a>.
    </p>


    <h3>Startup and cluster nodes' discovery</h3>


    <p>
        Since Akka Cluster typically needs a moment to discover all it's members,
        you might experience a short delay between the startup and interchanging messages among those nodes.
        You can verify the correctness of the setup by searching log output for "Member is Up" text.
        To make sure your three nodes have become members there should be something like this in the log output
        <pre>
        [info] - actors.ChatRoom - Member is Up: akka.tcp://application@127.0.0.1:2551
        [info] - actors.ChatRoom - Member is Up: akka.tcp://application@127.0.0.1:2552
        [info] - actors.ChatRoom - Member is Up: akka.tcp://application@127.0.0.1:2553
        </pre>
    </p>

    <p>
        In Linux/Unix environments you can also check the setup by issuing <code>netstat</code> command and
        observing the
        output, which should include akka remoting and http sockets in LISTEN state:

        <pre>
        ~/javeo/clustered-chat$ netstat -tulpn |grep java
        .....
        tcp6       0      0 127.0.0.1:2551          :::*                    LISTEN      14957/java
        tcp6       0      0 127.0.0.1:2552          :::*                    LISTEN      12809/java
        tcp6       0      0 127.0.0.1:2553          :::*                    LISTEN      13647/java
        tcp6       0      0 :::9001                 :::*                    LISTEN      14957/java
        tcp6       0      0 :::9002                 :::*                    LISTEN      12809/java
        tcp6       0      0 :::9003                 :::*                    LISTEN      13647/java
        .....
        </pre>
    </p>
    <p>
        Note that the user's nickname is stored in a cookie, so you can only have one active session per browser.
        You should open applications in different browsers or use private/incognito browser mode.
        After boot, please open three browsers with
        <a href="http://localhost:9001">localhost:9001</a>,
        <a href="http://localhost:9002">localhost:9002</a>,
        and <a href="http://localhost:9003">localhost:9003</a>
    </p>

    <p>
        Now you can define nicknames for all participants and start talking.
    </p>

    <h3>MongoDB</h3>

    <p>
        This project uses MongoDB, it means that in order to run it, you need to have MongoDB available on address
        "mongodb://localhost/" (the default mongo port is 27017).
    </p>

    <p>
        You can go to MongoDB's official page and follow the installation instructions, or you can use Docker and 
        create a container that runs MongoDB (see <a href="https://hub.docker.com/_/mongo/">docker hub</a>).
    </p>

    <p>
        When you have docker running, installing MongoDB is as easy as issuing this command:
        <pre>
            docker run -p 27017:27017 --name clustered-chat-mongo -d mongo
        </pre>
    </p>

    <p>
        For example, when I installed Ubuntu 17.04, these two commands were enough to install Docker and create
        a container with MongoDB:
        <pre>
            sudo apt install docker.io
            sudo docker run -p 27017:27017 --name clustered-chat-mongo -d mongo
        </pre>
    </p>

    <p>
        You can run the tests even if you don't have MongoDB installed, because of using "embedded-mongodb" in testing.
    </p>

    <h3>The databases</h3>

    <p>
        Each cluster node runs its own MongoDB instance, we simulate it by including the port number in database name
        (see the "mongodb.uri" setting in <a href="#code/conf/application.conf" class="shortcut">application.conf</a>
        file). One node will write to mongodb database named "db9001", the second one will write to "db9002" and
        you probably have already figured out the name of the third database.
    </p>

    <h3>The mechanics</h3>

    <p>
        Please note that the <code>/socket</code> context in <code>routes</code> file points to <code>controllers.Chat.socket</code>
        controller method.
        Take a look how connections are handled with use of Play's <code>WebSocket</code> handler.
        <br/>
        Each user has their own websocket open which is serviced by <a href="#code/app/actors/UserSocket.scala"
                                                                       class="shortcut">UserSocket.scala</a>.
        The <code>UserSocket</code> receives <code>play.api.libs.json.JSValue</code> messages from the user's
        browser, parses it and eventually publishes a <code>ChatMessage(topic: String, user: String, text: String)</code> (or <code>TopicNameMessage(topicName: String)</code> - indicating that a new topic was created).

        Upon it's creation, a <code>UserSocket</code> registers to the <code>DistributedPubSubMediator</code> by sending a
        <code>Subscribe</code> message with topic name "topics".
        This special topic is needed to give users ability to create topics and to inform all users about new topics.
        <br> To publish the message we use:
        <pre>
            mediator ! Publish(topic, ChatMessage(topic, uid, msg))
        </pre>
    </p>

    <p>
        The <code>DistributedPubSub</code> and the <code>mediator</code> Actor is used in the code to provide abstraction for message distribution between cluster nodes.
        It is a nice implementation of publish-subscribe communication style with named topics which uses actors Akka Routing under the hood to distribute messages in the cluster.
        The use of this feature is very simplistic since message passing is done same way as to local Actors - it is location transparent. One just has to subscribe to a named topic to receive distributed messages.
        This way, with use of <code>DistributedPubSub</code> there is no concern, or little about clustered environment upon message passing from programmer's point of view.
        In our template if you inspect the <code>UserSocket</code> Actor you will find that it subscribes to <code>mediator</code> :
        <pre>
            val mediator = DistributedPubSub(context.system).mediator
            mediator ! Subscribe(topicsTopic, self)
        </pre>
        When one of users creates a topic, his <code>UserSocket</code> will send a <code>TopicNameMessage</code> to the mediator. The system will deliver this message to all users, and a new topic name will be shown in each user's browser page along with the "subscribe" button.
        When a user clicks "subscribe", his <code>UserSocket</code> will send a <code>Subscribe</code> message to mediator. After that a user will communicate with others through the mediator by sending <code>ChatMessage</code> messages.
        The received ChatMessage is serialized and sent to <code>out</code>.
    </p>

    <p>
        For detailed information on this mechanism please check
        <a href="http://doc.akka.io/docs/akka/2.4.0/scala/distributed-pub-sub.html#DistributedPubSub_Extension">documentation</a>
        on Akka web page. Also take a look at Typesafe's
        <a href="https://www.typesafe.com/activator/template/akka-clustering">activator template</a> for more example
        use cases of <code>DistributedPubSub</code>.
    </p>

    <h3>A scenario of message distribution between nodes.</h3>

    <p>
        Let's play a scenario with six users - named A-F. The user A is connected to host on port 9001.
        Users B, C and D are connected to host on port 9002. The rest of them are connected to host on port 9003, as
        shown on the diagram below.
        <br/>
        <img src="tutorial/chat.png"/>
    </p>

    <p>As decribed above the <a href="http://doc.akka.io/docs/akka/2.4.0/common/cluster.html">Akka Cluster</a> feature is leveraged
        to implement the delivery of messages in a dispersed multi-node clustered environment.
        The steps below demonstrate how a chat message which is sent by user A from 9001 instance is broadcasted to
        all
        participants.
        <ol>
            <li>user <b>A</b> defines and sends a message, the corresponding <code>UserSocket</code> receives it</li>
            <li><b>A</b>'s <code>UserSocket</code> parses the message and sends to node <b>9001</b>'s
                <code>DistributedPubSubMediator</code>
            </li>
            <li><code>DistributedPubSubMediator</code> sends the message to all <code>UserSocket</code>
                cluster nodes (<b>9001</b>, <b>9002</b>, <b>9003</b>)
            </li>
            <li>eventually, each <code>UserSocket</code> sends a message to the browser where it is served to the
                client.
            </li>
        </ol>
        <img src="tutorial/flow.png"/>
        <br/>
    </p>

    <h3>Persistence.</h3>

    <p>
        The persistence is implemented in the <code>DBServiceImpl</code> Actor, it subscribes to <code>mediator</code>
        to two special topics:
        <pre>
            val mediator = DistributedPubSub(context.system).mediator
            ...
            mediator ! Subscribe(topicsTopic, self)
            mediator ! Subscribe(messagesTopic, self)
        </pre>
    </p>

    <p>
        These two topics are special because they are not chat topics that users see in their "topics" sidebar on the page.
        When a user creates a new topic, the <code>UserSocket</code> Actor publishes it to topicsTopic. When a user posts a
        message in a chat, the socket publishes it to two topics: the chat topic itself (that other sockets are subscribed to)
        and to special <code>messagesTopic</code> topic, to which <code>DBServiceImpl</code> Actors are subscribed:
        <pre>
            mediator ! Publish(topic, chatMessage)
            mediator ! Publish(messagesTopic, chatMessage)
        </pre>
    </p>

    <p>
        When a new message arrives, the <code>DBServiceImpl</code> Actor saves it in the database:
        <pre>
            case c : ChatMessageWithCreationDate =&gt;
              for {
                messagesColl &lt;- coll("messages")
                result &lt;- messagesColl.insert(c)
              } {
                // do nothing
              }
        </pre>

        The <code>coll</code> method returns a <code>play.modules.reactivemongo.json.collection.JSONCollection</code>
        found by provided name. After retrieving the collection, we invoke the <code>insert</code> method.
    </p>

    <p>
        What about retrieving data? Let's consider the simpler case of retrieving the topics list. The <code>find</code>
        method expects a <code>play.api.libs.json.JsObject</code> that represents the query.  We retrieve all the 
        topics from the database by passing an empty <code>JsObject</code> to the <code>find</code> method.
        <pre>
            val topicsFuture = for {
              topicsColl &lt;- coll("topics")
              topics &lt;- topicsColl.find(Json.obj()).cursor[Topic]().collect[List]()
            } yield topics
        </pre>
    </p>
</div>
<div>
    <h2>Testing</h2>

    <p>
        You can also take a moment to examine the approach to testing, actors in particular.
        <code>ChatMessageSpec</code> test verifies serialization to JSON of <code>ChatMessage</code>s.
        <code>UserSocketSpec</code> tests actor behaviour, and <code>DBSpec</code> tests DBService actor.
        The tests are based on <a href="https://etorreborre.github.io/specs2/">Specs2</a> and <a
            href="http://doc.akka.io/docs/akka/2.4.0/scala/testing.html">Akka akka-testkit</a> facilities
        including the TestProbe mocking class.
        The <code>tell</code> method is used to pass messages with second parameter to simulate the sending actor.
        The <code>expextMsg</code> method is used to assert message flow within the actor system in accordance with
        specification.
    </p>

    <h3>Mocking and embedding the database in tests</h3>

    <p>
        When testing the communication with the database, you can either mock it or embed the real instance of it. This project
        uses both approaches. There are two classes in <code>DBSpec.scala</code> file:
        <ul>
          <li>
            <code>DBServiceWithMockedMongoSpec</code>
          </li>
          <li>
            <code>DBServiceWithEmbeddedMongoSpec</code>
          </li>
        </ul>
    </p>

    <p>
        We use mocks provided by <a href="https://github.com/themillhousegroup/play2-reactivemongo-mocks">
        play2-reactivemongo-mocks</a> to simulate the initial delay in database availability and to test the cases when the
        database is empty.
    </p>

    <p>
        There is one caveat in <code>play2-reactivemongo-mocks</code> that prevents us from using it to test the cases
        when we insert or fetch the data from the database. There is a method named <code>givenMongoFindOperatesOn</code>
        that allows to specify the data which a mocked <code>JSONCollection</code> will be populated with.
        But if you use that method, the mocked collection will only allow <code>JSObject</code>s as parameters of its methods.
    </p>

    <p>
        It means that in our code in <code>DB.scala</code> we couldn't use the collection as follows:
        <code>
          result &lt;- topicsColl.insert(Topic(topicName))
        </code>
        The mocking framework demanded that we rewrite that piece of code to make it look like this:
        <code>
          result &lt;- topicsColl.insert(Json.asJson(Topic(topicName)))
        </code>
        Or to rewrite this:
        <code>
          topics &lt;- topicsColl.find(Json.obj()).cursor[Topic]().collect[List]()
        </code>
        ... to make look like this:
        <code>
          topics &lt;- topicsColl.find(Json.obj()).cursor[JsObject]().collect[List]()
        </code>
        That's why we embed MongoDB in those tests in which we assume that there is data in the database.
    </p>

    <p>
        The classes in <code>com.github.athieriot</code> package in the <code>test</code> folder are from
        <a href="https://github.com/athieriot/specs2-embedmongo">specs2-embedded-mongo</a> project. The project
        uses an outdated version of <code>specs2</code>, which is not compatible with Play Framework version that
        we use. There is a <a href="https://github.com/athieriot/specs2-embedmongo/pull/16">pull request</a>
        that moves the <code>specs2-embedmongo</code> to a new version of <code>specs2</code>. Until it's accepted,
        we can't rely on it and we have to embed its code in our project.
    </p>

</div>
<div>
    <h2>Summary</h2>
    <p>
        In this application template we have demonstrated how a message driven web application using
        <code>websockets</code>
        can be
        implemented with <a href="http://akka.io/">Akka</a> and scaled out thanks to <a
            href="http://doc.akka.io/docs/akka/2.4.0/common/cluster.html">Akka Cluster</a> at it's core.

        The application is a good starting point if you want to build a scalable and resilient cluster of <code>websocket</code>
        services.

        By adding cluster management facilities, whether simple load balancing (eg. with use <a
            href="http://www.haproxy.org/">HA Proxy</a>) or a complete (micro)service manager solution like <a
            href="http://www.typesafe.com/products/conductr">ConductR</a> or
        <a href="http://kubernetes.io/">Kubernetes</a> if you like Docker, you will get a complete, managed,
        scalable and reactive cluster of websocket services communicating with the frontend.
    </p>
</div>
</body>
</html>
